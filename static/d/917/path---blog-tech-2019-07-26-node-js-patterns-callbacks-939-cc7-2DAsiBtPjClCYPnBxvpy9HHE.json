{"data":{"markdownRemark":{"html":"<p>Node.JS callbacks are base on Reactor pattern. Reactor pattern is a way to execute operations asynchronously in single thread. In other words it is a way to do more work in same amount of time by not spending time on operations that do not take CPU time.</p>\n<p><em>In terms of Node.JS and JavaScript asynchronously operations is performing in the background.</em></p>\n<p>We are facing non CPU intense but time intensive operations when dealing with input and output. Input and output operations, most of the time mentioned as I/O operations. I/O operations: database requests, network requests, reading and writing to files, waiting for keyboard input or printing a file.</p>\n<h2>Reactor pattern</h2>\n<p>Let see how asynchronous operations looks inside a single-threaded execution environment.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">processData(callback) {\n  fs.read(&#39;data.txt&#39;, (err, bytesRead, buffer) =&gt; {\n    if (err) callback(err);\n    process(bytesRead, buffer, callback);\n  }\n}\nconsole.log(&#39;We call you back soon&#39;);</code></pre></div>\n<p>Here a bunch of patterns in the example above.</p>\n<p>First of all usage of a callback to release of current execution context from waiting for the potentially slow file system (what fs stands for) read operation. This way we will see \"We call you back soon\" log (print) statement in our console before the file being processed.</p>\n<p>The second. Callbacks first argument is always an error or null if no error happened.</p>\n<p>The third. Callback error handling: always handle the error case. Unhandled errors in callback code will lead to situations when no error happens but the code doesn't work.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if (err) /* handle error */;</code></pre></div>\n<p>The fourth. Callback error handling: do not throw inside the callback function. Callbacks are executed by the event loop and not in a place where you passed callback into some function. Thrown errors cannot be try/cactch -ed so you will end up with a terse stack trace from the event loop with a no way to debug the error.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">asyncFn(callback) {\n  // Do\n  if (err) callback(err);\n  // Don&#39;t\n  if (err) throw err;\n}</code></pre></div>\n<p>The fifth. Never mix asynchronous and synchronous returns. TODO an example.</p>\n<p>The last. Callbacks are passed as the last argument. This is a convention. It is harder a read code with callbacks when a callback as the second argument in a function call with for example 4 arguments.</p>","frontmatter":{"title":"Node JS patterns: Callbacks","description":"All you want to know about Callbacks","related":null}}},"pageContext":{"slug":"/blog/tech/2019-07-26-node-js-patterns-callbacks/","previous":{"fields":{"slug":"/blog/tech/2019-02-11-essential-books-that-every-programmer-should-read/"},"frontmatter":{"title":"Essential Books That Every Programmer Should Read","description":"The books recommendations from the Bozhidar's talk, lists by Uncle Bob, and Kent Beck, books from blog posts by Jeff Atwood and DHH.","date":"2019-02-11T00:00:00.000Z"}},"next":{"fields":{"slug":"/blog/tech/2019-08-09-node-js-patterns-observer/"},"frontmatter":{"title":"The Observer pattern","description":null,"date":null}}}}