{"data":{"markdownRemark":{"html":"<p>To illustrate this I invented one task.</p>\n<p>There is a Ruby on Rails project. The task is to determine whether a page visitor has access to a controller method before the method execution. The ideal task for a controller filter, now called <code>before_action</code> in Rails. But I need the data from the filter in the controller method itself. I do not want to make a second request for the same data again. I do not want to clutter up the session and do not want to assign an instance variable in the controller filter.</p>\n<p>With the constraint above I produced the solution below:</p>\n<pre><code class=\"language-ruby\"># Models: User, CustomerSpecialOffer, SpecialOffer\n#\n# User has_many CustomerSpecialOffer as customer\n# CustomerSpecialOffer belongs_to customer\n# CustomerSpecialOffer belongs_to SpecialOffer\n# SpecialOffer has_many CustomerSpecialOffer\n#\nclass SpecialOfferController &#x3C; ApplicationController\n  def show\n    customer_special_offer_code do |offer_code|\n      special_offer = SpecialOffer.find(params[:id])\n      render 'show', locals: { special_offer: special_offer, offer_code: offer_code }\n    end\n  end\n  \n  def no_offers\n  end\n\n  private\n\n  def customer_special_offer_code\n    offer_code = CustomerSpecialOffer\n      .where(special_offer_id: params[:id], customer: current_user)\n      .select(:offer_code)\n      .first\n\n    if offer_code\n      yield(offer_code)\n    else\n      redirect_to 'no_offers'\n    end\n  end\nend\n</code></pre>\n<p>The <code>#customer_special_offer_code</code> block acts as a filter and at the same time as a source of the required data <code>offer_code</code>.</p>\n<p>I did a check, acquire the data, set no instance variables in the controller scope and have no extra database queries. Job done!</p>\n<hr>\n<p>Very often the <code>before_action</code> method is used so that it only harms the code. For example, <a href=\"https://rails-bestpractices.com/posts/2010/07/24/use-before_filter/\">this “Best practice”</a> is wrong in my opinion in two reasons:</p>\n<ul>\n<li>the code has become harder to understand, you should look for more than one place to understand what’s going on</li>\n<li>controller inheritance is no longer an option, together with inherited methods, you will get all filters; although I do not recommend to consider inheritance with any resource controllers, ApplicationController, AdminController, and similar controllers are the exception.</li>\n</ul>\n<p>Following the statements above, I do not recommend to do this:</p>\n<pre><code class=\"language-ruby\">class UsersController &#x3C; ApplicationController\n  before_action :set_user, only: [:show, :edit, :update]\n  \n  def show\n  end\n  \n  def edit\n  end\n  \n  def update\n    if @user.update(user_params)\n      redirect_to @user, notice: 'User was successfully updated.'\n    else\n      render :edit\n    end\n  end\n  \n  private\n  \n  def set_user\n    @user = User.find(params[:id])\n  end\n  \n  def user_params\n    params.require(:user).permit(:name, :email, :password,\n                                 :password_confirmation)\n  end\nend\n</code></pre>","frontmatter":{"title":"An alternative to Rails `before_action`","description":"Rails `before_action` is a good tool but often used incorrectly. In this article, I will show what is wrong and my remedy for `before_action` abuse."}}},"pageContext":{"slug":"/blog/tech/2017-01-30-an-alternative-to-rails-before-action/","previous":null,"next":{"fields":{"slug":"/blog/tech/2019-04-07-hello-world/"},"frontmatter":{"title":"Hello world","description":null,"date":"2019-07-04T5:39:00Z+10"}}}}