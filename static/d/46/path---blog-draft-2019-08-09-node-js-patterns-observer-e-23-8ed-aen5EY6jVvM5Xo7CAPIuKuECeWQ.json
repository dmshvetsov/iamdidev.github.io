{"data":{"markdownRemark":{"html":"<h2>The Observer pattern</h2>\n<p>TODO explanation\nTODO example of combining callback with EventEmitter for exposing single function with clean API covered main use case and returning instance of EventEmitter for extra features.</p>\n<p>TODO: need title\nUsing callback-style programming can lead to callback hell or pyramid of doom. Some patterns to avoid this.\nSequential callback pattern\nfunction storeData(data, callback) {\nasyncStore(data, (err, storeResult) => {\nif (err) return callback(err);\ncallback(null, storeResult);\n});\n}\nfunction processRawData(rawData, callback) {\nasyncProcessing(result, (err, processedData) => {\nif (err) return callback(err);\nstoreData(processedData, callback);\n});\n}\nfunction startProcessing(args, callback) {\nasyncStart(args, (err, rawData) => {\nif (err) return callback(err);\nprocessRawData(rawData, callback);\n});\n}\nSometimes final function can be written in a terse manner, if arguments for async function callback are equal err + result of the async function.\nfunction storeData(data, callback) {\nasyncStore(data, callback);\n}\nIteration callback pattern\nfunction iterateAll() {\nconst iterate = (index) => {\nif (index === collection.length) {\nreturn callback();\n}\nconst item = collection[index];\nprocessItem(item, (err) => {\nif (err) return callback(err);\niterate(index + 1);\n});\n};\niterate(0);\n}\nThe pattern can be generalized as:\nfunction iterateOver(collection, fn, callback) {\nconst iterate = (index) => {\nif (index === collection.length) {\nreturn callback();\n}\nconst item = collection[index];\nfn(item, (err) => {\nif (err) return callback(err);\niterate(index + 1);\n});\n};\niterate(0);\n}\niterateWithCallback(\ncollection,\nprocessItem,\n() => console.log('done')\n);\nConcurrent callback pattern\nWhen an order of the execution of the callback over the collection doesn't matter concurrent pattern can drastically improve the performance of the asynchronous processing of the collection.\nfunction processConcurrently(collection, callback) {\nlet completed = 0;\nlet noErrors = false;</p>\n<p>  const processCallback = (err) => {\nif (err) {\nnoErrors = false;\nreturn callback(err);\n}\ncompleted += 1;\nif (completed === collection.length &#x26;&#x26; !hasError) {\ncallback();\n}\n};\ncollection.forEach(item => processItem(item, processCallback);\n}\nBe aware of race conditions because they can be possible in the concurrent pattern.\nTODO: Possible solution for a race condition in the concurrent pattern.\nLimited concurrent callback patter\nConsider a recursive example of the concurrent pattern:\nTODO: recursive concurrent pattern example\nQueues can help limit concurent execution\nTODO: recursive concurrent pattern example with a queue\nExamples can be looked up in async library.\nGenerators sequential pattern\nTODO\nGenerators concurent pattern\nTODO\nLimited concurrent pattern with queues\nTODO</p>","frontmatter":{"title":"The Observer pattern","description":null,"related":null}}},"pageContext":{"slug":"/blog/draft/2019-08-09-node-js-patterns-observer/","previous":{"fields":{"slug":"/blog/draft/0000-00-00-advices-for-junior-developers/"},"frontmatter":{"title":"Advices for junior developers","description":null,"date":null}},"next":{"fields":{"slug":"/blog/draft/0000-00-00-on-naming-things/"},"frontmatter":{"title":"On naming things","description":null,"date":null}}}}